/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/v1/auth/validate": {
    /**
     * Validate JWT
     * @description Validate a JWT token
     */
    get: operations["validateJWT"];
  };
  "/v1/user/models": {
    /** Get paginated models */
    get: operations["getModels"];
  };
  "/v1/models": {
    /** Get paginated models */
    get: operations["getAllModels"];
    /** Create a new model */
    post: operations["createModel"];
  };
  "/v1/models/search": {
    /** Search for models */
    get: operations["searchModels"];
  };
  "/v1/models/{modelId}/archive": {
    /**
     * Archive a model
     * @description Archives a model. Models that remain archived for more than 30 days will be permanently deleted.
     */
    post: operations["archiveModel"];
  };
  "/v1/models/{modelId}/unarchive": {
    /**
     * Unarchive a model
     * @description Unarchives a previously archived model. This will cancel any scheduled deletion.
     */
    post: operations["unarchiveModel"];
  };
  "/v1/user/shared-models": {
    /** Get paginated shared models */
    get: operations["getSharedModels"];
  };
  "/v1/user/archived-models": {
    /**
     * Get paginated archived models
     * @description Retrieve a paginated list of models that have been archived by the user
     */
    get: operations["getArchivedModels"];
  };
  "/v1/models/{id}": {
    /**
     * Get a Model
     * @description Retrieve a single model by its ID
     */
    get: operations["getModelById"];
    /**
     * Delete a Model
     * @description Delete a single model by its ID
     */
    delete: operations["deleteModelById"];
  };
  "/v1/models/legacy/{id}": {
    /**
     * Get a legacy model
     * @description Retrieve a single model by its ID
     */
    get: operations["getLegacyModelById"];
  };
  "/v1/models/{modelId}/predict": {
    /**
     * Predict with Model
     * @description Submit a dataset for prediction using a specific model
     */
    post: operations["predictWithModel"];
  };
  "/v1/models/{modelId}/predict/csv": {
    /**
     * Predict using CSV with Model
     * @description Submit a dataset for prediction using a specific model
     */
    post: operations["predictWithModelCSV"];
  };
  "/v1/models/{id}/partial": {
    /** Partially update specific fields of a model */
    patch: operations["partiallyUpdateModel"];
  };
  "/v1/models/{modelId}/features/{featureId}": {
    /**
     * Update a feature for a specific model
     * @description Update the name, description, and feature type of an existing feature within a specific model
     */
    patch: operations["partiallyUpdateModelFeature"];
  };
  "/v1/user/datasets": {
    /**
     * Get Datasets by User ID
     * @description Retrieve all datasets associated with a specific user ID
     */
    get: operations["getDatasets"];
  };
  "/v1/datasets/{id}": {
    /**
     * Get a Dataset
     * @description Retrieve a single dataset by its ID
     */
    get: operations["getDatasetById"];
  };
  "/v1/organizations": {
    /** Get all organizations for a specific user */
    get: operations["getAllOrganizationsForUser"];
    /** Create a new organization */
    post: operations["createOrganization"];
  };
  "/v1/user/organizations": {
    /** Get all user organizations */
    get: operations["getAllOrganizationsByUser"];
  };
  "/v1/organizations/{id}/partial": {
    /** Partially update an existing organization */
    patch: operations["partialUpdateOrganization"];
  };
  "/v1/organizations/{name}": {
    /** Get organization by name */
    get: operations["getOrganizationByName"];
  };
  "/v1/organizations/{orgName}/invitations": {
    /**
     * Get all invitations for an organization
     * @description This endpoint allows an organization admin to get all invitations for their organization.
     */
    get: operations["getAllInvitations"];
    /**
     * Create new invitations for an organization
     * @description This endpoint allows an organization admin to create new invitations for users.
     */
    post: operations["createInvitations"];
  };
  "/v1/organizations/{orgId}/invitations/{id}/resend": {
    /**
     * Resend an invitation email
     * @description This endpoint allows an organization admin to resend an invitation email if it has not expired. Only organization admins can access this endpoint.
     */
    post: operations["resendInvitation"];
  };
  "/v1/organizations/{name}/invitations/{uuid}": {
    /**
     * Get the status of an invitation
     * @description This endpoint allows a user to check the status of an invitation.
     */
    get: operations["getInvitation"];
    /**
     * Update the status of an invitation
     * @description This endpoint allows a user to update the status of an invitation.
     */
    put: operations["updateInvitation"];
  };
  "/v1/leads": {
    /**
     * Get All Leads
     * @description Retrieve all leads
     */
    get: operations["getAllLeads"];
    /**
     * Create a Lead
     * @description Create a new lead
     */
    post: operations["createLead"];
  };
  "/v1/leads/{id}": {
    /**
     * Get a Lead by ID
     * @description Retrieve a single lead by its ID
     */
    get: operations["getLeadById"];
    /**
     * Update a Lead by ID
     * @description Update the details of an existing lead
     */
    put: operations["updateLeadById"];
    /**
     * Delete a Lead by ID
     * @description Delete a single lead by its ID
     */
    delete: operations["deleteLeadById"];
  };
  "/v1/user/api-keys": {
    /**
     * Get All API Keys for the User
     * @description Retrieve all API keys associated with the authenticated user.
     */
    get: operations["getAllApiKeysForUser"];
    /**
     * Create an API Key for the User
     * @description Generate and return an API key for programmatic access. This API key is associated with the user and can be used for authenticating future requests.
     */
    post: operations["createApiKey"];
  };
  "/v1/user/api-keys/{key}": {
    /**
     * Delete an API Key
     * @description Delete a specific API key associated with the authenticated user. Only the user or an admin can delete keys.
     */
    delete: operations["deleteApiKey"];
    /**
     * Update API Key
     * @description Update an API key's metadata, such as its note or status (enable/disable).
     */
    patch: operations["updateApiKey"];
  };
  "/v1/user/settings": {
    /** Get user settings */
    get: operations["getUserSettings"];
    /** Create or update user settings */
    post: operations["saveUserSettings"];
  };
  "/v1/user/avatar": {
    /** Delete user avatar */
    delete: operations["deleteUserAvatar"];
  };
  "/v1/users/{username}": {
    /** Get user data */
    get: operations["getUser"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Model: {
      /**
       * Format: int64
       * @example 0
       */
      id?: number;
      /** @example My Model */
      name: string;
      /** @example A description of your model */
      description?: string;
      type: components["schemas"]["ModelType"];
      /** @example 1.0.0 */
      jaqpotpyVersion: string;
      doas?: components["schemas"]["Doa"][];
      libraries: components["schemas"]["Library"][];
      dependentFeatures: components["schemas"]["Feature"][];
      independentFeatures: components["schemas"]["Feature"][];
      sharedWithOrganizations?: components["schemas"]["Organization"][];
      visibility: components["schemas"]["ModelVisibility"];
      task: components["schemas"]["ModelTask"];
      archived?: boolean;
      /**
       * Format: date-time
       * @description The date and time when the model was last archived.
       * @example 2023-01-01T12:00:00Z
       */
      archivedAt?: string;
      torchConfig?: {
        [key: string]: components["schemas"]["AnyValue"];
      };
      preprocessors?: components["schemas"]["Transformer"][];
      featurizers?: components["schemas"]["Transformer"][];
      /**
       * Format: byte
       * @description A base64 representation of the raw preprocessor.
       */
      rawPreprocessor?: string;
      /**
       * Format: byte
       * @description A base64 representation of the raw model.
       */
      rawModel: string;
      creator?: components["schemas"]["User"];
      /** @description If the current user can edit the model */
      canEdit?: boolean;
      isAdmin?: boolean;
      selectedFeatures?: string[];
      tags?: string;
      legacyPredictionService?: string;
      scores?: {
        train?: components["schemas"]["Scores"][];
        test?: components["schemas"]["Scores"][];
        crossValidation?: components["schemas"]["Scores"][];
      };
      rPbpkConfig?: components["schemas"]["RPbpkConfig"];
      /**
       * Format: date-time
       * @description The date and time when the feature was created.
       * @example 2023-01-01T12:00:00Z
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description The date and time when the model was last updated.
       * @example 2023-01-01T12:00:00Z
       */
      updatedAt?: string;
    };
    ModelSummary: {
      /**
       * Format: int64
       * @example 0
       */
      id: number;
      /** @example My Model */
      name: string;
      visibility: components["schemas"]["ModelVisibility"];
      /** @example A description of your model */
      description?: string;
      creator?: components["schemas"]["User"];
      type: components["schemas"]["ModelType"];
      dependentFeaturesLength?: number;
      independentFeaturesLength?: number;
      sharedWithOrganizations: components["schemas"]["OrganizationSummary"][];
      /**
       * Format: date-time
       * @description The date and time when the feature was created.
       * @example 2023-01-01T12:00:00Z
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description The date and time when the feature was last updated.
       * @example 2023-01-01T12:00:00Z
       */
      updatedAt?: string;
    };
    Scores: {
      regression?: components["schemas"]["RegressionScores"];
      binaryClassification?: components["schemas"]["BinaryClassificationScores"];
      multiclassClassification?: components["schemas"]["MulticlassClassificationScores"];
    };
    RegressionScores: {
      yName: string;
      folds?: number;
      /** Format: float */
      r2?: number;
      /** Format: float */
      mae?: number;
      /** Format: float */
      rmse?: number;
    };
    BinaryClassificationScores: {
      labels?: string[];
      yName: string;
      folds?: number;
      /** Format: float */
      accuracy?: number;
      /** Format: float */
      balancedAccuracy?: number;
      precision?: number[];
      recall?: number[];
      f1Score?: number[];
      jaccard?: number[];
      /** Format: float */
      matthewsCorrCoef?: number;
      confusionMatrix?: number[][];
    };
    MulticlassClassificationScores: {
      labels?: string[];
      yName: string;
      folds?: number;
      /** Format: float */
      accuracy?: number;
      /** Format: float */
      balancedAccuracy?: number;
      precision?: number[];
      recall?: number[];
      f1Score?: number[];
      jaccard?: number[];
      /** Format: float */
      matthewsCorrCoef?: number;
      confusionMatrix?: number[][];
    };
    /** @description Configuration for the R PBPK models */
    RPbpkConfig: {
      odeSolver?: string;
    };
    OrganizationSummary: {
      /**
       * Format: int64
       * @example 0
       */
      id: number;
      /** @example My Organization */
      name: string;
    };
    /** @enum {string} */
    ModelType: "SKLEARN_ONNX" | "TORCH_SEQUENCE_ONNX" | "TORCH_GEOMETRIC_ONNX" | "TORCHSCRIPT" | "R_BNLEARN_DISCRETE" | "R_CARET" | "R_GBM" | "R_NAIVE_BAYES" | "R_PBPK" | "R_RF" | "R_RPART" | "R_SVM" | "R_TREE_CLASS" | "R_TREE_REGR" | "QSAR_TOOLBOX_CALCULATOR" | "QSAR_TOOLBOX_QSAR_MODEL" | "QSAR_TOOLBOX_PROFILER";
    /** @description A preprocessor for the model */
    Transformer: {
      /** Format: int64 */
      id?: number;
      /** @example StandardScaler */
      name: string;
      config: {
        [key: string]: components["schemas"]["AnyValue"];
      };
    };
    /** @enum {string} */
    ModelVisibility: "PUBLIC" | "ORG_SHARED" | "PRIVATE";
    /** @enum {string} */
    ModelTask: "REGRESSION" | "BINARY_CLASSIFICATION" | "MULTICLASS_CLASSIFICATION";
    Library: {
      /** Format: int64 */
      id?: number;
      /** @example Library Name */
      name: string;
      /** @example 1.24.0 */
      version: string;
      /**
       * Format: date-time
       * @description The date and time when the feature was created.
       * @example 2023-01-01T12:00:00Z
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description The date and time when the feature was last updated.
       * @example 2023-01-01T12:00:00Z
       */
      updatedAt?: string;
    };
    PredictionDoa: {
      /** Format: int64 */
      id?: number;
      method: components["schemas"]["DoaMethod"];
      /** @description The doa calculated data */
      data: {
        [key: string]: components["schemas"]["AnyValue"];
      };
      /**
       * Format: date-time
       * @description The date and time when the feature was created.
       * @example 2023-01-01T12:00:00Z
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description The date and time when the feature was last updated.
       * @example 2023-01-01T12:00:00Z
       */
      updatedAt?: string;
    };
    Doa: {
      /** Format: int64 */
      id?: number;
      method: components["schemas"]["DoaMethod"];
      data: {
        [key: string]: components["schemas"]["AnyValue"];
      };
      /**
       * Format: date-time
       * @description The date and time when the feature was created.
       * @example 2023-01-01T12:00:00Z
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description The date and time when the feature was last updated.
       * @example 2023-01-01T12:00:00Z
       */
      updatedAt?: string;
    };
    /**
     * @example LEVERAGE
     * @enum {string}
     */
    DoaMethod: "LEVERAGE" | "BOUNDING_BOX" | "KERNEL_BASED" | "MEAN_VAR" | "MAHALANOBIS" | "CITY_BLOCK";
    LeverageDoa: {
      /** Format: float */
      hStar?: number;
      doaMatrix?: number[][];
    };
    BoundingBoxDoa: {
      boundingBox?: number[][];
    };
    KernelBasedDoa: {
      /** Format: float */
      sigma?: number;
      /** Format: float */
      gamma?: number;
      /** Format: float */
      threshold?: number;
      /**
       * @example GAUSSIAN
       * @enum {string}
       */
      kernelType?: "GAUSSIAN" | "RBF" | "LAPLACIAN" | "PERCENTILE" | "MEAN_STD";
      dataPoints?: number[][];
    };
    MeanVarDoa: {
      bounds?: number[][];
    };
    MahalanobisDoa: {
      meanVector?: number[];
      invCovMatrix?: number[][];
      /** Format: float */
      threshold?: number;
    };
    CityBlockDoa: {
      meanVector?: number[];
      /** Format: float */
      threshold?: number;
    };
    Feature: {
      /**
       * Format: int64
       * @example 1
       */
      id?: number;
      /**
       * @description A key that must start with a letter, followed by any combination of letters, digits, hyphens, or underscores. For example, 'abc123', 'abc-test', or 'Abc_test'. It cannot start with a digit.
       * @example feature-key
       */
      key: string;
      /**
       * @description A name for the feature that will appear on top of the form field
       * @example A feature name
       */
      name: string;
      /**
       * @description The units for the feature
       * @example mg/s
       */
      units?: string;
      /**
       * @description The range for the feature
       * @example 0-100
       */
      range?: string;
      description?: string;
      featureType: components["schemas"]["FeatureType"];
      /**
       * @example DEPENDENT
       * @enum {string}
       */
      featureDependency?: "DEPENDENT" | "INDEPENDENT";
      /** @example true */
      visible?: boolean;
      possibleValues?: components["schemas"]["FeaturePossibleValue"][];
      /**
       * Format: date-time
       * @description The date and time when the feature was created.
       * @example 2023-01-01T12:00:00Z
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description The date and time when the feature was last updated.
       * @example 2023-01-01T12:00:00Z
       */
      updatedAt?: string;
    };
    FeaturePossibleValue: {
      /** @example value */
      value: string;
      /** @example my description */
      description: string;
    };
    /**
     * @example FLOAT
     * @enum {string}
     */
    FeatureType: "INTEGER" | "FLOAT" | "CATEGORICAL" | "SMILES" | "STRING" | "TEXT" | "BOOLEAN" | "FLOAT_ARRAY" | "STRING_ARRAY";
    /**
     * @example PREDICTION
     * @enum {string}
     */
    DatasetType: "PREDICTION";
    Dataset: {
      /**
       * Format: int64
       * @example 1
       */
      id?: number;
      type: components["schemas"]["DatasetType"];
      /**
       * @example ARRAY
       * @enum {string}
       */
      entryType: "ARRAY";
      input: unknown[];
      result?: unknown[];
      /** @enum {string} */
      status?: "CREATED" | "EXECUTING" | "FAILURE" | "SUCCESS";
      failureReason?: string;
      userId?: string;
      /** Format: int64 */
      modelId?: number;
      modelName?: string;
      /** Format: date-time */
      executedAt?: string;
      /** Format: date-time */
      executionFinishedAt?: string;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    DatasetCSV: {
      /**
       * Format: int64
       * @example 1
       */
      id?: number;
      type: components["schemas"]["DatasetType"];
      /**
       * Format: byte
       * @description A base64 representation in CSV format of the input values.
       */
      inputFile: string;
      values?: unknown[];
      /** @enum {string} */
      status?: "CREATED" | "EXECUTING" | "FAILURE" | "SUCCESS";
      failureReason?: string;
      /** Format: int64 */
      modelId?: number;
      modelName?: string;
      /** Format: date-time */
      executedAt?: string;
      /** Format: date-time */
      executionFinishedAt?: string;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    Organization: {
      /** Format: int64 */
      id?: number;
      /** @example my-awesome-org */
      name: string;
      creator?: components["schemas"]["User"];
      visibility: components["schemas"]["OrganizationVisibility"];
      /** @example An awesome organization for managing models. */
      description?: string;
      organizationMembers?: components["schemas"]["OrganizationUser"][];
      /** @example contact@my-awesome-org.com */
      contactEmail: string;
      /** @example +1234567890 */
      contactPhone?: string;
      /** @example http://www.my-awesome-org.com */
      website?: string;
      /** @example 123 Organization St., City, Country */
      address?: string;
      /** @description If the current user can edit the organization */
      canEdit?: boolean;
      /** @description If the current user is a member of the organization */
      isMember?: boolean;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    OrganizationUser: {
      /** Format: int64 */
      id?: number;
      userId: string;
      username?: string;
      /** Format: email */
      email?: string;
      avatarUrl?: string;
      associationType: components["schemas"]["OrganizationUserAssociationType"];
    };
    /** @enum {string} */
    OrganizationUserAssociationType: "ADMIN" | "MEMBER";
    /** @enum {string} */
    OrganizationVisibility: "PUBLIC" | "PRIVATE";
    OrganizationInvitation: {
      /**
       * Format: uuid
       * @description ID of the invitation
       */
      id?: string;
      /** @description The user id associated with that invitation */
      userId?: string;
      /**
       * Format: email
       * @description Email address of the invited user
       */
      userEmail: string;
      /**
       * @description Status of the invitation
       * @enum {string}
       */
      status: "PENDING" | "REJECTED" | "ACCEPTED";
      /**
       * Format: date-time
       * @description Expiration date of the invitation
       */
      expirationDate: string;
    };
    Lead: {
      /** Format: int64 */
      id?: number;
      email?: string;
      name?: string;
      /** @enum {string} */
      status?: "PENDING" | "APPROVED" | "DENIED";
    };
    PredictionModel: {
      /**
       * Format: int64
       * @description Unique identifier for the prediction model
       */
      id?: number | null;
      /** @description List of dependent features for the model */
      dependentFeatures: components["schemas"]["Feature"][];
      /** @description List of independent features for the model */
      independentFeatures: components["schemas"]["Feature"][];
      type: components["schemas"]["ModelType"];
      /** @description Raw model data in serialized format */
      rawModel: string;
      /** @description Raw preprocessor data in serialized format */
      rawPreprocessor?: string;
      /** @description List of Domain of Applicability (DoA) configurations */
      doas?: components["schemas"]["PredictionDoa"][];
      /** @description List of feature names selected for the model */
      selectedFeatures?: string[];
      task: components["schemas"]["ModelTask"];
      /** @description List of featurizer configurations applied to the model */
      featurizers?: components["schemas"]["Transformer"][];
      /** @description List of preprocessor configurations applied to the model */
      preprocessors?: components["schemas"]["Transformer"][];
      /** @description Torch configuration settings, optional */
      torchConfig?: {
        [key: string]: components["schemas"]["AnyValue"];
      } | null;
      rPbpkOdeSolver?: string;
      /** @description Legacy additional information settings, optional */
      legacyAdditionalInfo?: {
        [key: string]: components["schemas"]["AnyValue"];
      } | null;
      /** @description Legacy prediction service information, if available */
      legacyPredictionService?: string | null;
    };
    PredictionRequest: {
      model: components["schemas"]["PredictionModel"];
      dataset: components["schemas"]["Dataset"];
    };
    PredictionResponse: {
      predictions: components["schemas"]["AnyValue"][];
    };
    /** User */
    User: {
      id: string;
      username?: string;
      firstName?: string;
      lastName?: string;
      email?: string;
      emailVerified?: boolean;
      avatarUrl?: string;
      canEdit?: boolean;
    };
    UserSettings: {
      /** Format: int64 */
      id?: number;
      /** @default false */
      darkMode?: boolean;
      /** @default false */
      collapseSidebar?: boolean;
      avatarUrl?: string;
      isAdmin?: boolean;
      isUpciUser?: boolean;
    };
    ApiKey: {
      /**
       * @description The generated API key
       * @example jq_abcd1234efgh5678ijkl
       */
      clientKey?: string;
      /** @description A note for the API key */
      note?: string;
      /**
       * @description The ID of the user associated with the API key
       * @example 12345
       */
      userId?: string;
      /**
       * Format: date-time
       * @description The expiration time of the API key (if any)
       * @example 2024-12-31T23:59:59Z
       */
      expiresAt?: string | null;
      /** @enum {string} */
      expirationTime: "THREE_MONTHS" | "SIX_MONTHS";
      /**
       * Format: date-time
       * @description The last time the API key was used
       * @example 2024-09-23T12:00:00Z
       */
      lastUsed?: string | null;
      /**
       * @description The IP address from which the API key was last used
       * @example 192.168.1.1
       */
      lastUsedIp?: string | null;
      /** @description Whether the API key is active or disabled */
      enabled?: boolean;
    };
    ErrorResponse: {
      /** @description Error message */
      message?: string;
      /** @description Error code */
      code?: number;
    };
    /** @enum {string} */
    ErrorCode: "1001";
    /** @description Can be any value - string, number, boolean, array or object. */
    AnyValue: unknown;
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Validate JWT
   * @description Validate a JWT token
   */
  validateJWT: {
    responses: {
      /** @description JWT is valid */
      200: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
    };
  };
  /** Get paginated models */
  getModels: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
        sort?: string[];
      };
    };
    responses: {
      /** @description Paginated list of models */
      200: {
        content: {
          "application/json": {
            content?: components["schemas"]["ModelSummary"][];
            totalElements?: number;
            totalPages?: number;
            pageSize?: number;
            pageNumber?: number;
          };
        };
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
    };
  };
  /** Get paginated models */
  getAllModels: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
        sort?: string[];
      };
    };
    responses: {
      /** @description Paginated list of models */
      200: {
        content: {
          "application/json": {
            content?: components["schemas"]["ModelSummary"][];
            totalElements?: number;
            totalPages?: number;
            pageSize?: number;
            pageNumber?: number;
          };
        };
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
    };
  };
  /** Create a new model */
  createModel: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Model"];
      };
    };
    responses: {
      /** @description Model created successfully */
      201: {
        content: never;
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
    };
  };
  /** Search for models */
  searchModels: {
    parameters: {
      query: {
        query: string;
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Paginated list of models */
      200: {
        content: {
          "application/json": {
            content?: components["schemas"]["ModelSummary"][];
            totalElements?: number;
            totalPages?: number;
            pageSize?: number;
            pageNumber?: number;
          };
        };
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
    };
  };
  /**
   * Archive a model
   * @description Archives a model. Models that remain archived for more than 30 days will be permanently deleted.
   */
  archiveModel: {
    parameters: {
      path: {
        /** @description The ID of the model to archive */
        modelId: number;
      };
    };
    responses: {
      /** @description Model successfully archived */
      200: {
        content: {
          "application/json": {
            /**
             * Format: int64
             * @example 0
             */
            id?: number;
            /**
             * Format: date-time
             * @description Timestamp when the model was archived
             */
            archivedAt?: string;
          };
        };
      };
      /** @description Insufficient permissions to archive the model */
      403: {
        content: never;
      };
      /** @description Model not found */
      404: {
        content: never;
      };
      /** @description Model is already archived */
      409: {
        content: never;
      };
    };
  };
  /**
   * Unarchive a model
   * @description Unarchives a previously archived model. This will cancel any scheduled deletion.
   */
  unarchiveModel: {
    parameters: {
      path: {
        /** @description The ID of the model to unarchive */
        modelId: number;
      };
    };
    responses: {
      /** @description Model successfully unarchived */
      200: {
        content: {
          "application/json": {
            /**
             * Format: int64
             * @example 0
             */
            id?: number;
          };
        };
      };
      /** @description Insufficient permissions to unarchive the model */
      403: {
        content: never;
      };
      /** @description Model not found */
      404: {
        content: never;
      };
      /** @description Model is not currently archived */
      409: {
        content: never;
      };
    };
  };
  /** Get paginated shared models */
  getSharedModels: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
        sort?: string[];
        organizationId?: number;
      };
    };
    responses: {
      /** @description Paginated list of shared models */
      200: {
        content: {
          "application/json": {
            content?: components["schemas"]["ModelSummary"][];
            totalElements?: number;
            totalPages?: number;
            pageSize?: number;
            pageNumber?: number;
          };
        };
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
    };
  };
  /**
   * Get paginated archived models
   * @description Retrieve a paginated list of models that have been archived by the user
   */
  getArchivedModels: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
        sort?: string[];
      };
    };
    responses: {
      /** @description Paginated list of archived models */
      200: {
        content: {
          "application/json": {
            content?: components["schemas"]["ModelSummary"][];
            totalElements?: number;
            totalPages?: number;
            pageSize?: number;
            pageNumber?: number;
          };
        };
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
      /** @description Insufficient permissions to access archived models */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get a Model
   * @description Retrieve a single model by its ID
   */
  getModelById: {
    parameters: {
      path: {
        /** @description The ID of the model to retrieve */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Model"];
        };
      };
      /** @description Model not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete a Model
   * @description Delete a single model by its ID
   */
  deleteModelById: {
    parameters: {
      path: {
        /** @description The ID of the model to delete */
        id: number;
      };
    };
    responses: {
      /** @description Model deleted successfully */
      204: {
        content: never;
      };
      /** @description Model not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get a legacy model
   * @description Retrieve a single model by its ID
   */
  getLegacyModelById: {
    parameters: {
      path: {
        /** @description The ID of the model to retrieve */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Model"];
        };
      };
      /** @description Model not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Predict with Model
   * @description Submit a dataset for prediction using a specific model
   */
  predictWithModel: {
    parameters: {
      path: {
        /** @description The ID of the model to use for prediction */
        modelId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Dataset"];
      };
    };
    responses: {
      /** @description Prediction created successfully */
      201: {
        content: never;
      };
      /** @description Invalid Request */
      400: {
        content: never;
      };
      /** @description Model not found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Predict using CSV with Model
   * @description Submit a dataset for prediction using a specific model
   */
  predictWithModelCSV: {
    parameters: {
      path: {
        /** @description The ID of the model to use for prediction */
        modelId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DatasetCSV"];
      };
    };
    responses: {
      /** @description Prediction created successfully */
      201: {
        content: never;
      };
      /** @description Invalid Request */
      400: {
        content: never;
      };
      /** @description Model not found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Partially update specific fields of a model */
  partiallyUpdateModel: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name: string;
          description?: string;
          visibility: components["schemas"]["ModelVisibility"];
          task: components["schemas"]["ModelTask"];
          tags?: string;
          sharedWithOrganizationIds?: number[];
        };
      };
    };
    responses: {
      /** @description Model fields updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Model"];
        };
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
      /** @description Model not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update a feature for a specific model
   * @description Update the name, description, and feature type of an existing feature within a specific model
   */
  partiallyUpdateModelFeature: {
    parameters: {
      path: {
        /** @description The ID of the model containing the feature */
        modelId: number;
        /** @description The ID of the feature to update */
        featureId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description A name for the feature that will appear on top of the form field
           * @example Updated Feature Name
           */
          name: string;
          /**
           * @description The units that this feature is using
           * @example mg/L
           */
          units?: string;
          /**
           * @description The range that this feature is using
           * @example 0-100
           */
          range?: string;
          /** @example An updated description for this feature */
          description?: string;
          featureType: components["schemas"]["FeatureType"];
          possibleValues?: components["schemas"]["FeaturePossibleValue"][];
        };
      };
    };
    responses: {
      /** @description Feature updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Feature"];
        };
      };
      /** @description Invalid input */
      400: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Model or feature not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get Datasets by User ID
   * @description Retrieve all datasets associated with a specific user ID
   */
  getDatasets: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
        sort?: string[];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            content?: components["schemas"]["Dataset"][];
            totalElements?: number;
            totalPages?: number;
            pageSize?: number;
            pageNumber?: number;
          };
        };
      };
      /** @description User or datasets not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get a Dataset
   * @description Retrieve a single dataset by its ID
   */
  getDatasetById: {
    parameters: {
      path: {
        /** @description The ID of the dataset to retrieve */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      /** @description Model not found */
      404: {
        content: never;
      };
    };
  };
  /** Get all organizations for a specific user */
  getAllOrganizationsForUser: {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": components["schemas"]["Organization"][];
        };
      };
    };
  };
  /** Create a new organization */
  createOrganization: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Organization"];
      };
    };
    responses: {
      /** @description Organization created successfully */
      201: {
        content: never;
      };
    };
  };
  /** Get all user organizations */
  getAllOrganizationsByUser: {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": components["schemas"]["Organization"][];
        };
      };
    };
  };
  /** Partially update an existing organization */
  partialUpdateOrganization: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name: string;
          description?: string;
          /** Format: email */
          contactEmail: string;
          visibility: components["schemas"]["OrganizationVisibility"];
        };
      };
    };
    responses: {
      /** @description Organization updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Organization"];
        };
      };
      /** @description Organization not found */
      404: {
        content: never;
      };
    };
  };
  /** Get organization by name */
  getOrganizationByName: {
    parameters: {
      path: {
        name: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": components["schemas"]["Organization"];
        };
      };
      /** @description Organization not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get all invitations for an organization
   * @description This endpoint allows an organization admin to get all invitations for their organization.
   */
  getAllInvitations: {
    parameters: {
      path: {
        /** @description Name of the organization */
        orgName: string;
      };
    };
    responses: {
      /** @description Invitations retrieved successfully */
      200: {
        content: {
          "application/json": components["schemas"]["OrganizationInvitation"][];
        };
      };
      /** @description Bad request, invalid input */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Unauthorized, only admins can access this endpoint */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Organization not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Create new invitations for an organization
   * @description This endpoint allows an organization admin to create new invitations for users.
   */
  createInvitations: {
    parameters: {
      path: {
        /** @description Name of the organization */
        orgName: string;
      };
    };
    /** @description Invitation request payload */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description List of email addresses to invite
           * @example [
           *   "user1@example.com",
           *   "user2@example.com"
           * ]
           */
          emails?: string[];
        };
      };
    };
    responses: {
      /** @description Invitations created successfully */
      201: {
        content: never;
      };
      /** @description Bad request, invalid input */
      400: {
        content: never;
      };
      /** @description Unauthorized, only admins can create invitations */
      401: {
        content: never;
      };
      /** @description Too many requests, rate limit exceeded */
      429: {
        content: never;
      };
    };
  };
  /**
   * Resend an invitation email
   * @description This endpoint allows an organization admin to resend an invitation email if it has not expired. Only organization admins can access this endpoint.
   */
  resendInvitation: {
    parameters: {
      path: {
        /** @description ID of the organization */
        orgId: number;
        /** @description ID of the invitation */
        id: string;
      };
    };
    responses: {
      /** @description Invitation resent successfully */
      200: {
        content: never;
      };
      /** @description Bad request, invalid input */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Unauthorized, only organization admins can access this endpoint */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Organization or invitation not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Gone, the invitation has expired */
      410: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get the status of an invitation
   * @description This endpoint allows a user to check the status of an invitation.
   */
  getInvitation: {
    parameters: {
      path: {
        /** @description Name of the organization */
        name: string;
        /** @description UUID of the invitation */
        uuid: string;
      };
    };
    responses: {
      /** @description Invitation status retrieved successfully */
      200: {
        content: {
          "application/json": components["schemas"]["OrganizationInvitation"];
        };
      };
      /** @description Bad request, invalid input */
      400: {
        content: never;
      };
      /** @description Invitation not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update the status of an invitation
   * @description This endpoint allows a user to update the status of an invitation.
   */
  updateInvitation: {
    parameters: {
      path: {
        /** @description Name of the organization */
        name: string;
        /** @description UUID of the invitation */
        uuid: string;
      };
    };
    /** @description Invitation status update payload */
    requestBody: {
      content: {
        "application/json": components["schemas"]["OrganizationInvitation"];
      };
    };
    responses: {
      /** @description Invitation status updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["OrganizationInvitation"];
        };
      };
      /** @description Bad request, invalid input */
      400: {
        content: never;
      };
      /** @description Invitation not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get All Leads
   * @description Retrieve all leads
   */
  getAllLeads: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Lead"][];
        };
      };
    };
  };
  /**
   * Create a Lead
   * @description Create a new lead
   */
  createLead: {
    responses: {
      /** @description Lead created successfully */
      201: {
        content: never;
      };
      /** @description Invalid request data */
      400: {
        content: never;
      };
    };
  };
  /**
   * Get a Lead by ID
   * @description Retrieve a single lead by its ID
   */
  getLeadById: {
    parameters: {
      path: {
        /** @description The ID of the lead to retrieve */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Lead"];
        };
      };
      /** @description Lead not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update a Lead by ID
   * @description Update the details of an existing lead
   */
  updateLeadById: {
    parameters: {
      path: {
        /** @description The ID of the lead to update */
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Lead"];
      };
    };
    responses: {
      /** @description Lead updated successfully */
      200: {
        content: never;
      };
      /** @description Invalid request data */
      400: {
        content: never;
      };
      /** @description Lead not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete a Lead by ID
   * @description Delete a single lead by its ID
   */
  deleteLeadById: {
    parameters: {
      path: {
        /** @description The ID of the lead to delete */
        id: number;
      };
    };
    responses: {
      /** @description Lead deleted successfully */
      204: {
        content: never;
      };
      /** @description Lead not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get All API Keys for the User
   * @description Retrieve all API keys associated with the authenticated user.
   */
  getAllApiKeysForUser: {
    responses: {
      /** @description Successful Response with the user's API keys */
      200: {
        content: {
          "application/json": {
              /** @description The API key */
              clientKey?: string;
              /** @description Description of the API key */
              note?: string;
              /**
               * Format: date-time
               * @description Creation timestamp of the API key
               */
              createdAt?: string;
              /**
               * Format: date-time
               * @description Expiration timestamp of the API key (optional)
               */
              expiresAt?: string;
              /** @description Whether the API key is active or disabled */
              enabled?: boolean;
            }[];
        };
      };
      /** @description Unauthorized request, the user must be authenticated */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create an API Key for the User
   * @description Generate and return an API key for programmatic access. This API key is associated with the user and can be used for authenticating future requests.
   */
  createApiKey: {
    /** @description Payload to create a new API key */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApiKey"];
      };
    };
    responses: {
      /** @description API Key created successfully */
      201: {
        content: {
          "application/json": {
            /**
             * @description The generated API key
             * @example jq_abcd1234efgh5678ijkl
             */
            clientKey?: string;
            /** @description The generated API secret */
            clientSecret?: string;
          };
        };
      };
      /** @description Invalid input, such as a missing user ID */
      400: {
        content: never;
      };
      /** @description Unauthorized request, the user must be authenticated */
      401: {
        content: never;
      };
      /** @description User not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete an API Key
   * @description Delete a specific API key associated with the authenticated user. Only the user or an admin can delete keys.
   */
  deleteApiKey: {
    parameters: {
      path: {
        /** @description The API key to delete */
        key: string;
      };
    };
    responses: {
      /** @description API key deleted successfully */
      204: {
        content: never;
      };
      /** @description Unauthorized request, the user must be authenticated */
      401: {
        content: never;
      };
      /** @description API key not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update API Key
   * @description Update an API key's metadata, such as its note or status (enable/disable).
   */
  updateApiKey: {
    parameters: {
      path: {
        /** @description The API key to update */
        key: string;
      };
    };
    /** @description Payload to update API key metadata */
    requestBody: {
      content: {
        "application/json": {
          /** @description Updated description for the API key */
          note?: string;
          /** @description Set to `false` to disable the API key */
          enabled?: boolean;
        };
      };
    };
    responses: {
      /** @description API key updated successfully */
      200: {
        content: {
          "application/json": {
            /** @description The updated API key */
            key?: string;
            /** @description The updated description of the API key */
            note?: string;
            /** @description Whether the API key is active or disabled */
            enabled?: boolean;
          };
        };
      };
      /** @description Invalid request, such as malformed input */
      400: {
        content: never;
      };
      /** @description Unauthorized request, the user must be authenticated */
      401: {
        content: never;
      };
      /** @description API key not found */
      404: {
        content: never;
      };
    };
  };
  /** Get user settings */
  getUserSettings: {
    responses: {
      /** @description User settings retrieved successfully */
      200: {
        content: {
          "application/json": components["schemas"]["UserSettings"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Settings not found */
      404: {
        content: never;
      };
    };
  };
  /** Create or update user settings */
  saveUserSettings: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserSettings"];
      };
    };
    responses: {
      /** @description Settings saved successfully */
      200: {
        content: {
          "application/json": components["schemas"]["UserSettings"];
        };
      };
      /** @description Invalid request */
      400: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
    };
  };
  /** Delete user avatar */
  deleteUserAvatar: {
    responses: {
      /** @description Avatar successfully deleted */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Avatar not found */
      404: {
        content: never;
      };
    };
  };
  /** Get user data */
  getUser: {
    parameters: {
      path: {
        /** @description The ID of the user to retrieve */
        username: string;
      };
    };
    responses: {
      /** @description User data retrieved successfully */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User not found */
      404: {
        content: never;
      };
    };
  };
}
